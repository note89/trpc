{
  "title": "7. Explore Real-Time Capabilities with Subscriptions",
  "id": "cJIeSN1AWiFSGs29k6rb7qteFAl66dFFnK9Ka9We7ec=",
  "steps": [
    {
      "type": "textOnly",
      "description": "Welcome to this code tour on implementing real-time features in tRPC using subscriptions and WebSockets! In this tour, we'll explore how tRPC enables real-time communication between the client and server, allowing for dynamic updates and live data streams. We'll cover the key concepts, implementation details, and best practices for working with subscriptions in tRPC.",
      "title": "",
      "id": "913"
    },
    {
      "type": "textOnly",
      "description": "Welcome to the tour on implementing real-time features in tRPC using subscriptions and WebSockets! In this tour, we'll explore how tRPC enables seamless real-time communication between clients and servers. We'll cover the core concepts, implementation details, and best practices for building robust, type-safe real-time applications. Let's dive in!",
      "title": "",
      "id": "930"
    },
    {
      "type": "revealFiles",
      "files": ["packages/server/src/observable/types.ts"],
      "description": "At the heart of tRPC's real-time features lies the `Observable` type. This powerful abstraction represents a stream of asynchronous data, making it perfect for handling real-time updates. Let's examine the `Observable` interface:",
      "title": "",
      "id": "931"
    },
    {
      "type": "highlight",
      "description": "The `Observable` interface extends `Subscribable` and provides a `pipe` method for chaining operations. Here are the key parts:\n\n1. The `subscribe` method allows observers to receive updates.\n2. The `pipe` method enables functional composition of operations on the observable stream.\n3. Generic types `TValue` and `TError` ensure type safety for the emitted values and errors.",
      "file": "packages/server/src/observable/types.ts",
      "highlight": [{ "start": 8, "end": 47 }],
      "title": "",
      "id": "932"
    },
    {
      "type": "highlight",
      "description": "The `Observer` interface defines how subscribers interact with Observables. It has three key methods:\n\n1. `next`: Called when a new value is emitted.\n2. `error`: Called when an error occurs in the observable stream.\n3. `complete`: Called when the observable stream completes.\n\nThis structure allows for flexible handling of real-time data and events.",
      "file": "packages/server/src/observable/types.ts",
      "highlight": [{ "start": 49, "end": 53 }],
      "title": "",
      "id": "933"
    },
    {
      "type": "highlight",
      "description": "The `applyWSSHandler` function sets up WebSocket support on the server. Key features include:\n\n1. Handling new WebSocket connections.\n2. Setting up event listeners for messages and connection events.\n3. Implementing a keep-alive mechanism to maintain long-lived connections.\n4. Providing a method to broadcast reconnect notifications to all clients.",
      "file": "packages/server/src/adapters/ws.ts",
      "highlight": [{ "start": 492, "end": 524 }],
      "title": "",
      "id": "934"
    },
    {
      "type": "highlight",
      "description": "The `createWSClient` function sets up a WebSocket client with robust connection management:\n\n1. It handles connection attempts with exponential backoff for retries.\n2. Implements a message queue for sending requests.\n3. Manages subscriptions and reconnections.\n4. Provides options for lazy connections to optimize performance.\n\nThis client is the foundation for real-time communication in tRPC applications.",
      "file": "packages/client/src/links/wsLink.ts",
      "highlight": [{ "start": 80, "end": 482 }],
      "title": "",
      "id": "935"
    },
    {
      "type": "highlight",
      "description": "Here's an example of defining subscriptions in a tRPC router for a real-time chat application:\n\n1. The `onAdd` subscription emits new chat messages as they're added.\n2. The `whoIsTyping` subscription provides real-time updates on which users are currently typing.\n\nNote how these subscriptions use the `observable` function to create streams of data that clients can subscribe to.",
      "file": "examples/next-prisma-websockets-starter/src/server/routers/post.ts",
      "highlight": [{ "start": 122, "end": 150 }],
      "title": "",
      "id": "936"
    },
    {
      "type": "highlight",
      "description": "This React component showcases how to use tRPC subscriptions:\n\n1. The `onAdd` subscription is used to receive new messages in real-time.\n2. The `whoIsTyping` subscription provides live updates on who's currently typing.\n3. Error handling is implemented to invalidate the cache and potentially retry on subscription errors.\n\nThis pattern allows for seamless integration of real-time data into React applications.",
      "file": "examples/next-prisma-websockets-starter/src/pages/index.tsx",
      "highlight": [{ "start": 163, "end": 179 }],
      "title": "",
      "id": "937"
    },
    {
      "type": "textOnly",
      "description": "Congratulations! You've now explored the key aspects of implementing real-time features in tRPC using subscriptions and WebSockets. We've covered:\n\n1. The Observable pattern that powers tRPC's subscription system\n2. Server-side WebSocket setup\n3. Client-side WebSocket connection management\n4. Defining subscriptions in tRPC routers\n5. Using subscriptions in React components\n\nRemember, real-time features require careful consideration of error handling and connection management. tRPC provides a robust, type-safe foundation for building real-time applications.\n\nTo deepen your understanding, try implementing a small real-time feature in your own tRPC project. Happy coding!",
      "title": "",
      "id": "938"
    },
    {
      "type": "revealFiles",
      "files": ["packages/server/src/observable/observable.ts"],
      "description": "Now, let's look at how the `observable` function is implemented. This function is crucial for creating observables that power tRPC's subscription system.",
      "title": "",
      "id": "915"
    },
    {
      "type": "revealFiles",
      "files": ["packages/server/src/adapters/ws.ts"],
      "description": "With the core observable implementation in place, let's examine how WebSocket support is added on the server side using the `applyWSSHandler` function.",
      "title": "",
      "id": "916"
    },
    {
      "type": "revealFiles",
      "files": ["packages/client/src/links/wsLink.ts"],
      "description": "Let's examine the `wsLink` function, which is crucial for connecting the client to the WebSocket server. This function creates a tRPC link that enables real-time communication.\n\nThe `wsLink` function takes options including a WebSocket client and transformer. It returns a function that creates an observable for each operation. This observable handles the WebSocket communication, including sending requests, receiving responses, and managing subscriptions.\n\nKey points to note:\n1. It uses the provided transformer to serialize inputs and deserialize outputs.\n2. It handles different types of operations (queries, mutations, and subscriptions) appropriately.\n3. For subscriptions, it keeps the connection open for continuous updates.\n4. It includes error handling to manage WebSocket-specific issues.\n\nThis implementation allows tRPC to seamlessly integrate real-time features into its type-safe RPC system.",
      "title": "",
      "id": "917"
    },
    {
      "type": "revealFiles",
      "files": [
        "examples/next-prisma-websockets-starter/src/server/routers/post.ts"
      ],
      "description": "Let's examine how subscriptions are defined in a tRPC router using EventEmitter for real-time updates. This example shows a chat application with typing indicators and message updates.\n\nThe EventEmitter is crucial here:\n1. It allows procedures to emit events when data changes.\n2. Subscriptions listen to these events and push updates to clients.\n3. This event-driven approach enables efficient real-time communication.\n\nNotice how 'add' and 'isTypingUpdate' events are used to trigger updates for new messages and typing status changes, respectively.",
      "title": "",
      "id": "918"
    },
    {
      "type": "revealFiles",
      "files": ["examples/next-prisma-websockets-starter/src/pages/index.tsx"],
      "description": "Let's examine how subscriptions are used in a React component to enable real-time updates. This example demonstrates two key subscriptions: one for new posts and another for tracking who is currently typing.\n\nFocus on lines 163-172 and 175-179. These useSubscription hooks are crucial for real-time functionality:\n\n1. The post.onAdd subscription (lines 163-172) listens for new posts and updates the UI in real-time.\n2. The post.whoIsTyping subscription (lines 175-179) provides live updates on users currently typing.\n\nThese subscriptions leverage the WebSocket connection we set up earlier, allowing the server to push updates to the client instantly. When new data arrives, the respective callbacks (onData) are triggered, updating the component's state and re-rendering the UI with the latest information.\n\nNotice how error handling is implemented in the post.onAdd subscription (lines 167-171). This ensures robustness by invalidating the cache and potentially refetching data if the subscription encounters an error.\n\nBy using these subscriptions, the component maintains a live connection to the server, enabling a responsive and interactive user experience without constant polling.",
      "title": "",
      "id": "919"
    },
    {
      "type": "revealFiles",
      "files": ["packages/client/src/links/wsLink.ts"],
      "description": "Real-time applications need robust error handling and connection management. Let's examine how tRPC handles these aspects in the WebSocket link.",
      "title": "",
      "id": "920"
    },
    {
      "type": "textOnly",
      "description": "We've now explored the key aspects of implementing real-time features in tRPC using subscriptions and WebSockets. We've seen how observables power the subscription system, how to set up WebSocket support on both the server and client, and how to use subscriptions in a React application. Remember that real-time features require careful consideration of error handling and connection management. With tRPC, you can build robust, type-safe real-time applications with ease.",
      "title": "",
      "id": "921"
    }
  ]
}
