{"title":"7. Explore Real-Time Capabilities with Subscriptions","id":"cJIeSN1AWiFSGs29k6rb7qteFAl66dFFnK9Ka9We7ec=","steps":[{"type":"textOnly","description":"Welcome to this code tour on implementing real-time features in tRPC using subscriptions and WebSockets! In this tour, we'll explore how tRPC enables real-time communication between the client and server, allowing for dynamic updates and live data streams. We'll cover the key concepts, implementation details, and best practices for working with subscriptions in tRPC.","title":"","id":"913"},{"type":"revealFiles","files":["packages/server/src/observable/types.ts"],"description":"At the heart of tRPC's real-time features lies the `Observable` type. This powerful abstraction represents a stream of asynchronous data, making it perfect for handling real-time updates. Let's examine the `Observable` interface:","title":"","id":"931"},{"type":"highlight","description":"The `Observable` interface extends `Subscribable` and provides a `pipe` method for chaining operations. Here are the key parts:\n\n1. The `subscribe` method allows observers to receive updates.\n2. The `pipe` method enables functional composition of operations on the observable stream.\n3. Generic types `TValue` and `TError` ensure type safety for the emitted values and errors.","file":"packages/server/src/observable/types.ts","highlight":[{"start":8,"end":47}],"title":"","id":"932"},{"type":"highlight","description":"The `Observer` interface defines how subscribers interact with Observables. It has three key methods:\n\n1. `next`: Called when a new value is emitted.\n2. `error`: Called when an error occurs in the observable stream.\n3. `complete`: Called when the observable stream completes.\n\nThis structure allows for flexible handling of real-time data and events.","file":"packages/server/src/observable/types.ts","highlight":[{"start":49,"end":53}],"title":"","id":"933"},{"type":"highlight","description":"The `applyWSSHandler` function sets up WebSocket support on the server. Key features include:\n\n1. Handling new WebSocket connections.\n2. Setting up event listeners for messages and connection events.\n3. Implementing a keep-alive mechanism to maintain long-lived connections.\n4. Providing a method to broadcast reconnect notifications to all clients.","file":"packages/server/src/adapters/ws.ts","highlight":[{"start":492,"end":524}],"title":"","id":"934"},{"type":"highlight","description":"The `createWSClient` function sets up a WebSocket client with robust connection management:\n\n1. It handles connection attempts with exponential backoff for retries.\n2. Implements a message queue for sending requests.\n3. Manages subscriptions and reconnections.\n4. Provides options for lazy connections to optimize performance.\n\nThis client is the foundation for real-time communication in tRPC applications.","file":"packages/client/src/links/wsLink.ts","highlight":[{"start":80,"end":482}],"title":"","id":"935"},{"type":"highlight","description":"The `createWSClient` function is the core of tRPC's WebSocket client implementation. It sets up a robust WebSocket connection with features like automatic reconnection, message queuing, and subscription management. Let's examine its structure:","file":"packages/client/src/links/wsLink.ts","highlight":[{"start":80,"end":90}],"title":"","id":"1009"},{"type":"highlight","description":"The WebSocket client manages different connection states. The `Connection` type represents these states, allowing the client to handle 'open', 'closed', and 'connecting' states appropriately:","file":"packages/client/src/links/wsLink.ts","highlight":[{"start":130,"end":145}],"title":"","id":"1010"},{"type":"highlight","description":"The `dispatch` function is responsible for sending messages over the WebSocket connection. It batches messages for efficiency and handles connection state changes:","file":"packages/client/src/links/wsLink.ts","highlight":[{"start":150,"end":177}],"title":"","id":"1011"},{"type":"highlight","description":"The WebSocket client implements a robust reconnection mechanism. The `tryReconnect` and `reconnect` functions handle connection attempts with exponential backoff:","file":"packages/client/src/links/wsLink.ts","highlight":[{"start":178,"end":209}],"title":"","id":"1012"},{"type":"highlight","description":"The WebSocket client processes incoming messages using event listeners. It handles both responses to client requests and server-initiated messages like reconnection requests:","file":"packages/client/src/links/wsLink.ts","highlight":[{"start":304,"end":363}],"title":"","id":"1013"},{"type":"highlight","description":"Error handling and connection closure are crucial for maintaining a robust WebSocket connection. The client handles various scenarios, including unexpected closures and reconnection attempts:","file":"packages/client/src/links/wsLink.ts","highlight":[{"start":365,"end":401}],"title":"","id":"1014"},{"type":"highlight","description":"The `wsLink` function creates a tRPC link that uses the WebSocket client. It handles serialization, deserialization, and manages subscriptions:","file":"packages/client/src/links/wsLink.ts","highlight":[{"start":499,"end":548}],"title":"","id":"1015"},{"type":"highlight","description":"Here's an example of defining subscriptions in a tRPC router for a real-time chat application:\n\n1. The `onAdd` subscription emits new chat messages as they're added.\n2. The `whoIsTyping` subscription provides real-time updates on which users are currently typing.\n\nNote how these subscriptions use the `observable` function to create streams of data that clients can subscribe to.","file":"examples/next-prisma-websockets-starter/src/server/routers/post.ts","highlight":[{"start":122,"end":150}],"title":"","id":"936"},{"type":"highlight","description":"This React component showcases how to use tRPC subscriptions:\n\n1. The `onAdd` subscription is used to receive new messages in real-time.\n2. The `whoIsTyping` subscription provides live updates on who's currently typing.\n3. Error handling is implemented to invalidate the cache and potentially retry on subscription errors.\n\nThis pattern allows for seamless integration of real-time data into React applications.","file":"examples/next-prisma-websockets-starter/src/pages/index.tsx","highlight":[{"start":163,"end":179}],"title":"","id":"937"},{"type":"revealFiles","files":["examples/next-prisma-websockets-starter/src/server/routers/post.ts"],"description":"Let's examine how subscriptions are defined in a tRPC router using EventEmitter for real-time updates. This example shows a chat application with typing indicators and message updates.\n\nThe EventEmitter is crucial here:\n1. It allows procedures to emit events when data changes.\n2. Subscriptions listen to these events and push updates to clients.\n3. This event-driven approach enables efficient real-time communication.\n\nNotice how 'add' and 'isTypingUpdate' events are used to trigger updates for new messages and typing status changes, respectively.","title":"","id":"918"},{"type":"revealFiles","files":["examples/next-prisma-websockets-starter/src/pages/index.tsx"],"description":"Let's examine how subscriptions are used in a React component to enable real-time updates. This example demonstrates two key subscriptions: one for new posts and another for tracking who is currently typing.\n\nFocus on lines 163-172 and 175-179. These useSubscription hooks are crucial for real-time functionality:\n\n1. The post.onAdd subscription (lines 163-172) listens for new posts and updates the UI in real-time.\n2. The post.whoIsTyping subscription (lines 175-179) provides live updates on users currently typing.\n\nThese subscriptions leverage the WebSocket connection we set up earlier, allowing the server to push updates to the client instantly. When new data arrives, the respective callbacks (onData) are triggered, updating the component's state and re-rendering the UI with the latest information.\n\nNotice how error handling is implemented in the post.onAdd subscription (lines 167-171). This ensures robustness by invalidating the cache and potentially refetching data if the subscription encounters an error.\n\nBy using these subscriptions, the component maintains a live connection to the server, enabling a responsive and interactive user experience without constant polling.","title":"","id":"919"},{"type":"textOnly","description":"Congratulations! You've now explored the key aspects of implementing real-time features in tRPC using subscriptions and WebSockets. We've covered:\n\n1. The Observable pattern that powers tRPC's subscription system\n2. Server-side WebSocket setup\n3. Client-side WebSocket connection management\n4. Defining subscriptions in tRPC routers\n5. Using subscriptions in React components\n\nRemember, real-time features require careful consideration of error handling and connection management. tRPC provides a robust, type-safe foundation for building real-time applications.\n\nTo deepen your understanding, try implementing a small real-time feature in your own tRPC project. Happy coding!","title":"","id":"938"}]}