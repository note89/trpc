{"title":"1. Understand the Purpose and Structure of tRPC","id":"JL/Macfh1HuSCMzxTnixTuIXWq7Oki1sHMgcFNZ3a0U=","steps":[{"type":"textOnly","description":"Welcome to the tour of tRPC's core implementation! tRPC is a TypeScript-first RPC framework that enables end-to-end type-safety in client-server communication.\n\nKey components of tRPC's architecture:\n1. Router: Defines the API structure and procedures\n2. Procedure Builder: Creates type-safe API endpoints\n3. Client: Provides type-safe interaction with the API\n4. Links: Handle communication between client and server\n\nThese components work together to create a seamless, type-safe RPC system. The router defines the API structure, procedures specify endpoint behavior, the client interacts with the API, and links manage the actual data transfer.\n\nIn this tour, we'll explore each of these components in detail, examining their implementation and how they contribute to tRPC's type-safety and efficiency. Let's begin with the foundation and gradually build up to more complex parts of the system.","title":"","id":"808"},{"type":"highlight","description":"Let's begin by examining the `initTRPC` function, which is the entry point for creating a tRPC instance. This function is crucial as it sets up the core configuration for your tRPC application. It's typically used like this:\n\n```typescript\nconst t = initTRPC.create();\n```\n\nThe `initTRPC` function returns a builder object that allows you to customize various aspects of your tRPC setup. In the following steps, we'll explore its key components and how they contribute to tRPC's type-safety and flexibility.","file":"packages/server/src/unstable-core-do-not-import/initTRPC.ts","highlight":[{"start":152,"end":154}],"title":"","id":"956"},{"type":"highlight","description":"The `TRPCBuilder` class is the heart of the `initTRPC` function. It provides methods for configuring the context, metadata, and other aspects of your tRPC instance. Let's look at its structure:","file":"packages/server/src/unstable-core-do-not-import/initTRPC.ts","highlight":[{"start":46,"end":64}],"title":"","id":"957"},{"type":"highlight","description":"The `create` method of the `TRPCBuilder` class is where tRPC's core configuration is set up. This method is crucial as it defines the foundation for your tRPC instance, including error handling, data transformation, and environment settings.","file":"packages/server/src/unstable-core-do-not-import/initTRPC.ts","highlight":[{"start":70,"end":145}],"title":"","id":"961"},{"type":"highlight","description":"The `create` method starts by defining a complex type `$Root`. This type is key to tRPC's type safety, as it captures the context, metadata, error shape, and transformer configuration. Notice how it uses conditional types to infer the correct shapes based on the provided options.","file":"packages/server/src/unstable-core-do-not-import/initTRPC.ts","highlight":[{"start":75,"end":82}],"title":"","id":"962"},{"type":"highlight","description":"Next, the method creates a `config` object. This object is the heart of your tRPC instance, defining how data is transformed, whether you're in development mode, error formatting, and more. Note how it uses default values and optional chaining to provide sensible defaults while allowing for customization.","file":"packages/server/src/unstable-core-do-not-import/initTRPC.ts","highlight":[{"start":84,"end":99}],"title":"","id":"963"},{"type":"highlight","description":"tRPC includes a server-side check to prevent accidental use of server code in non-server environments. This is an important security feature that helps maintain the separation between client and server code.","file":"packages/server/src/unstable-core-do-not-import/initTRPC.ts","highlight":[{"start":101,"end":110}],"title":"","id":"964"},{"type":"highlight","description":"Finally, the `create` method returns an object containing the core components for building your tRPC API. This includes the procedure builder, middleware factory, router factory, and more. These components, built on the configuration we've just examined, provide the building blocks for creating your type-safe API.","file":"packages/server/src/unstable-core-do-not-import/initTRPC.ts","highlight":[{"start":111,"end":145}],"title":"","id":"965"},{"type":"highlight","description":"Let's examine the `createRouterFactory` function, which is central to tRPC's router creation process. This function is responsible for generating a factory that creates tRPC routers. It's a key part of tRPC's architecture, enabling the definition of type-safe API endpoints.","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":155,"end":222}],"title":"","id":"834"},{"type":"highlight","description":"The function begins by checking for reserved words in the input. This prevents naming conflicts and ensures the router's integrity.","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":165,"end":175}],"title":"","id":"835"},{"type":"highlight","description":"Next, let's look at the `step` function. This internal function recursively builds the router structure, handling nested routers and procedures.","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":177,"end":201}],"title":"","id":"836"},{"type":"textOnly","description":"Let's examine the `step` function, which is crucial for building the router structure. This internal function recursively processes the input to create a hierarchical representation of routers and procedures.","title":"","id":"966"},{"type":"highlight","description":"The `step` function begins by creating an `aggregate` object to store the processed items. It then iterates over each entry in the input object:","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":177,"end":179}],"title":"","id":"967"},{"type":"highlight","description":"If the current item is a router, the function recursively calls itself to process the nested router:","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":180,"end":183}],"title":"","id":"968"},{"type":"highlight","description":"If the item is not a procedure, it's treated as a potential nested structure and processed recursively:","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":184,"end":188}],"title":"","id":"969"},{"type":"highlight","description":"For individual procedures, the function creates a new path by joining the current path with the key. It then checks for duplicates and adds the procedure to both the `procedures` object and the `aggregate`:","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":190,"end":198}],"title":"","id":"970"},{"type":"highlight","description":"Finally, the function returns the `aggregate` object, which now contains the processed structure of routers and procedures:","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":200,"end":201}],"title":"","id":"971"},{"type":"highlight","description":"After building the router structure, the function creates the router definition. This includes the configuration, procedures, and other essential properties.","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":202,"end":210}],"title":"","id":"837"},{"type":"highlight","description":"Finally, the function returns the built router. This includes the record of procedures, the router definition, and a `createCaller` function for executing procedures.","file":"packages/server/src/unstable-core-do-not-import/router.ts","highlight":[{"start":212,"end":222}],"title":"","id":"838"},{"type":"highlight","description":"The ProcedureBuilder interface is a crucial part of tRPC's type-safe API definition. It's used to construct individual procedures (queries, mutations, or subscriptions) that are then combined into a router.\n\nThis interface allows you to chain methods like .input(), .output(), and .query() or .mutation() to define your procedure's behavior. For example:\n\nconst userProcedure = t.procedure.input(userSchema).query(({ input }) => { ... });\n\nHere, we're defining an input validator and a query resolver. This procedure can then be added to a router:\n\nconst userRouter = t.router({ getUser: userProcedure });\n\nThe ProcedureBuilder's type parameters ensure end-to-end type safety throughout your API.","file":"packages/server/src/unstable-core-do-not-import/procedureBuilder.ts","highlight":[{"start":162,"end":380}],"title":"","id":"811"},{"type":"highlight","description":"The ProcedureBuilder interface is the cornerstone of tRPC's type-safe API definition. It allows you to construct individual procedures (queries, mutations, or subscriptions) with full type safety. Let's examine its structure:","file":"packages/server/src/unstable-core-do-not-import/procedureBuilder.ts","highlight":[{"start":162,"end":171}],"title":"","id":"1000"},{"type":"highlight","description":"The `input` method allows you to add an input parser to your procedure. This is where you define the shape and validation rules for the input data. The complex type definition ensures that the input remains type-safe throughout the chain of method calls:","file":"packages/server/src/unstable-core-do-not-import/procedureBuilder.ts","highlight":[{"start":172,"end":197}],"title":"","id":"1001"},{"type":"highlight","description":"The `output` method adds an output parser to your procedure. This defines the shape of the data that your procedure will return. Like the input method, it maintains type safety throughout the procedure chain:","file":"packages/server/src/unstable-core-do-not-import/procedureBuilder.ts","highlight":[{"start":198,"end":213}],"title":"","id":"1002"},{"type":"highlight","description":"The `meta` method lets you attach metadata to your procedure. This can be useful for adding additional information or context to your procedures:","file":"packages/server/src/unstable-core-do-not-import/procedureBuilder.ts","highlight":[{"start":214,"end":229}],"title":"","id":"1003"},{"type":"highlight","description":"The `use` method allows you to add middleware to your procedure. Middlewares can perform actions before the main procedure logic, such as authentication or logging:","file":"packages/server/src/unstable-core-do-not-import/procedureBuilder.ts","highlight":[{"start":230,"end":258}],"title":"","id":"1004"},{"type":"highlight","description":"The `query` method defines a query procedure. Query procedures are typically used for fetching data and don't modify server state. Notice how it returns either a function or a QueryProcedure type, depending on the TCaller parameter:","file":"packages/server/src/unstable-core-do-not-import/procedureBuilder.ts","highlight":[{"start":296,"end":316}],"title":"","id":"1005"},{"type":"highlight","description":"The `mutation` method defines a mutation procedure. Mutations are used for operations that modify server state. Like the query method, it returns either a function or a MutationProcedure type:","file":"packages/server/src/unstable-core-do-not-import/procedureBuilder.ts","highlight":[{"start":318,"end":338}],"title":"","id":"1006"},{"type":"highlight","description":"The `subscription` method defines a subscription procedure. Subscriptions are used for real-time updates. Note that it returns a TypeError for TCaller, as subscriptions are not implemented for direct calling:","file":"packages/server/src/unstable-core-do-not-import/procedureBuilder.ts","highlight":[{"start":340,"end":358}],"title":"","id":"1007"},{"type":"highlight","description":"Let's examine the `createTRPCClient` function, a crucial part of tRPC's client-side implementation. This function creates a type-safe client for interacting with your tRPC API.\n\nIn a typical application, you'd use it like this:\n\nconst client = createTRPCClient<AppRouter>({ url: 'http://localhost:3000/trpc' });\n\nHere, `AppRouter` is the type of your server-side router, ensuring end-to-end type safety. The client mirrors the structure of your API, allowing you to make fully typed calls like `client.users.getUser.query({ id: 1 })`.\n\nNotice how the implementation uses `createTRPCClientProxy` to create this type-safe interface. This proxy maps directly to the procedures defined in your server-side router, maintaining the type information throughout the entire request/response cycle.\n\nExamine the highlighted code to see how tRPC achieves this elegant type-safe client creation.","file":"packages/client/src/createTRPCClient.ts","highlight":[{"start":150,"end":156}],"title":"","id":"812"},{"type":"highlight","description":"The `httpBatchLink` is a crucial component of tRPC's client-side optimization. It implements request batching, a technique that significantly improves API performance by combining multiple API calls into a single HTTP request.\n\nBatching reduces network overhead by:\n1. Minimizing the number of HTTP requests\n2. Reducing total data transferred\n3. Leveraging HTTP/2 multiplexing more effectively\n\nThe `httpBatchLink` function creates a link that automatically batches compatible requests within a short time window. This process is transparent to the application code, allowing developers to write normal procedure calls while benefiting from optimized network communication.\n\nIn the implementation, note how it handles batching logic, request validation, and response parsing. This efficient batching mechanism is a key feature that sets tRPC apart from traditional API architectures, enabling high-performance, type-safe remote procedure calls.","file":"packages/client/src/links/httpBatchLink.ts","highlight":[{"start":21,"end":137}],"title":"","id":"813"},{"type":"highlight","description":"The `createTRPCReact` function is crucial for integrating tRPC with React applications. It generates a set of custom hooks that provide type-safe access to your API procedures.\n\nHere's how you might use it:\n\n```typescript\nconst trpc = createTRPCReact<AppRouter>();\n\n// In a component:\nconst { data, isLoading } = trpc.users.getUser.useQuery({ id: 1 });\n```\n\nNotice how the `getUser` procedure's input and output types are automatically inferred. This showcases tRPC's end-to-end type safety, where types defined on the server seamlessly propagate to the client.\n\nExamine the implementation to understand how this type information is preserved across the server-client boundary.","file":"packages/react-query/src/createTRPCReact.tsx","highlight":[{"start":323,"end":333}],"title":"","id":"814"},{"type":"highlight","description":"Error handling is a critical aspect of any API system, and tRPC provides robust mechanisms for managing errors across the server and client. The `TRPCError` class is the foundation of error handling in tRPC.\n\nOn the server side, you can throw `TRPCError` instances in your procedures. These errors are automatically serialized and sent to the client with the appropriate HTTP status code.\n\nOn the client side, these errors are caught and transformed into `TRPCClientError` instances, which preserve the original error information. This allows for consistent error handling across the entire application.\n\nThe `code` property of `TRPCError` corresponds to specific HTTP status codes, enabling seamless integration with HTTP-based APIs.\n\nWhen using React hooks provided by tRPC, errors are easily accessible in the `error` property of the returned object, allowing for straightforward error handling and display in your components.\n\nThis error system ensures type-safety and consistency in error handling throughout your tRPC application, from server to client.","file":"packages/server/src/unstable-core-do-not-import/error/TRPCError.ts","highlight":[{"start":56,"end":82}],"title":"","id":"815"},{"type":"textOnly","description":"We've now explored the core components of tRPC: initialization, router creation, procedure definition, client creation, network communication, React integration, and error handling. These pieces work together to create a seamless, type-safe RPC system for TypeScript applications. tRPC's power comes from its ability to provide end-to-end type safety while keeping the API simple and flexible.","title":"","id":"816"}]}