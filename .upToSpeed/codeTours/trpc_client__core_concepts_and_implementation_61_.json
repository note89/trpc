{
  "title": "tRPC Client: Core Concepts and Implementation",
  "id": "ppqCtd2s4croBqLvDUcG7HXTOhMYJyUSrV5z2+P6eIo=",
  "steps": [
    {
      "type": "textOnly",
      "description": "Welcome to the tour of the @trpc/client package! This package is a crucial part of the tRPC ecosystem, providing the client-side implementation for interacting with tRPC servers. In this tour, we'll explore the main components and concepts of the client package, giving you a high-level understanding of how it works and how to use it effectively.",
      "title": "",
      "id": "1440"
    },
    {
      "type": "textOnly",
      "description": "The @trpc/client package plays a vital role in the tRPC ecosystem by enabling type-safe communication between the client and server. It provides several key components:\n\n1. createTRPCClient: A function to create a type-safe tRPC client.\n2. httpBatchLink: A link for batching HTTP requests.\n3. httpLink: A basic HTTP link for making requests.\n4. wsLink: A WebSocket link for real-time communication.\n5. splitLink: A utility for conditionally choosing between different links.\n\nThese components work together to provide a seamless and type-safe experience when interacting with tRPC servers. Throughout this tour, we'll explore how these components are implemented and used. Note that while we'll touch on links, there are separate, more detailed tours available for in-depth coverage of links and dataloaders.",
      "title": "",
      "id": "1441"
    },
    {
      "type": "revealFiles",
      "files": ["packages/client/src/index.ts"],
      "description": "Let's start by looking at the main entry point of the package, which exports all the essential components.",
      "title": "",
      "id": "1427"
    },
    {
      "type": "highlight",
      "description": "The most important export here is `createTRPCClient`. This function is used to create a typed tRPC client that can interact with your tRPC server.",
      "file": "packages/client/src/index.ts",
      "highlight": [{ "start": 3, "end": 4 }],
      "title": "",
      "id": "1428"
    },
    {
      "type": "highlight",
      "description": "Another key export is `TRPCClientError`. This custom error class is used for handling tRPC-specific errors on the client side.",
      "file": "packages/client/src/index.ts",
      "highlight": [{ "start": 6, "end": 6 }],
      "title": "",
      "id": "1429"
    },
    {
      "type": "revealFiles",
      "files": ["packages/client/src/createTRPCClient.ts"],
      "description": "Let's take a closer look at the `createTRPCClient.ts` file, which is the heart of the client package.",
      "title": "",
      "id": "1431"
    },
    {
      "type": "highlight",
      "description": "The `createTRPCClient` function is a cornerstone of tRPC's type inference system. It leverages advanced TypeScript features to infer types from your router definition, enabling end-to-end type safety.\n\nHere's how it works:\n1. It uses conditional types and mapped types to extract the structure of your router (see `createTRPCClientProxy` etc for more details).\n2. It creates a typed proxy that mirrors your router's structure, allowing you to call procedures as if they were local functions.\n3. The inferred types include input types, output types, and even error shapes, ensuring complete type coverage.\n\nThis type inference is what sets tRPC apart from other RPC systems. As a senior TypeScript engineer, you'll appreciate how this eliminates the need for manual type definitions or code generation steps, reducing potential discrepancies between client and server types.\n\nThe highlighted code shows the import of key types used in this process. While we won't dive deep into the implementation details in this tour, understanding that these types form the foundation of tRPC's type inference system is crucial.",
      "file": "packages/client/src/createTRPCClient.ts",
      "highlight": [{ "start": 150, "end": 156 }],
      "title": "",
      "id": "1432"
    },
    {
      "type": "textOnly",
      "description": "The createTRPCClient function creates a proxy object that mirrors your router's structure. This is a key concept in tRPC that allows you to interact with your server procedures as if they were local functions.",
      "title": "",
      "id": "1442"
    },
    {
      "type": "highlight",
      "description": "tRPC provides full type inference for your router client. The `inferRouterClient` type uses TypeScript's advanced type system to create a strongly-typed client interface that matches your server's router structure.",
      "file": "packages/client/src/createTRPCClient.ts",
      "highlight": [{ "start": 29, "end": 30 }],
      "title": "",
      "id": "1443"
    },
    {
      "type": "highlight",
      "description": "The `ResolverDef` type defines the structure of each procedure in your router. It includes the input and output types, whether a transformer is used, and the shape of any errors that might occur.",
      "file": "packages/client/src/createTRPCClient.ts",
      "highlight": [{ "start": 32, "end": 36 }],
      "title": "",
      "id": "1444"
    },
    {
      "type": "textOnly",
      "description": "Let's see a practical example of how to use the created tRPC client in a typical application:\n\n```typescript\nimport { createTRPCClient } from '@trpc/client';\nimport type { AppRouter } from './server/router'; // Your router type\n\n// Create the tRPC client\nconst client = createTRPCClient<AppRouter>({\n  url: 'http://localhost:3000/trpc',\n});\n\n// Use the client to call a procedure\nasync function fetchUser(userId: string) {\n  try {\n    const user = await client.user.get.query({ id: userId });\n    console.log(user);\n  } catch (error) {\n    console.error('Error fetching user:', error);\n  }\n}\n\nfetchUser('123');\n```\n\nIn this example, we create a tRPC client and use it to call a 'user.get' procedure. Notice how we can use the client with full type safety, as if we were calling a local function.",
      "title": "",
      "id": "1445"
    },
    {
      "type": "revealFiles",
      "files": ["packages/client/src/TRPCClientError.ts"],
      "description": "Now, let's examine how tRPC handles errors on the client side with the `TRPCClientError` class.",
      "title": "",
      "id": "1434"
    },
    {
      "type": "highlight",
      "description": "The `TRPCClientError` class extends the standard Error class and includes additional properties like `shape`, `data`, and `meta` to provide more context about the error.",
      "file": "packages/client/src/TRPCClientError.ts",
      "highlight": [{ "start": 43, "end": 81 }],
      "title": "",
      "id": "1435"
    },
    {
      "type": "highlight",
      "description": "The `TRPCClientError.from()` static method is a factory function that creates `TRPCClientError` instances from various error types, handling different scenarios and preserving error information.",
      "file": "packages/client/src/TRPCClientError.ts",
      "highlight": [{ "start": 83, "end": 116 }],
      "title": "",
      "id": "1436"
    },
    {
      "type": "revealFiles",
      "files": ["packages/client/src/links/httpBatchLink.ts"],
      "description": "Let's discuss the concept of links in tRPC, which are a crucial part of the client package. Links allow you to customize the behavior of your tRPC client, controlling how requests are sent and processed.\n\nLinks in tRPC form a chain of operations that your requests go through. They can be used for various purposes such as batching requests, adding headers, handling retries, or implementing caching strategies.\n\nOne commonly used link is the `httpBatchLink`, which we can see in this file. The `httpBatchLink` allows batching multiple tRPC calls into a single HTTP request, which can significantly improve performance for applications that make many small requests.\n\nHowever, there are many other types of links available in tRPC, such as `httpLink` for single HTTP requests, `wsLink` for WebSocket connections, or custom links that you can create for specific needs.\n\nIt's important to note that while we're briefly touching on links here, there are separate, more detailed tours available that dive deeper into the concept of links and how to use them effectively in your tRPC setup. These tours will provide a more comprehensive understanding of how to leverage links for optimizing your client-server communication.",
      "title": "",
      "id": "1437"
    },
    {
      "type": "highlight",
      "description": "The `httpBatchLink` is used to batch multiple tRPC calls into a single HTTP request, which can significantly improve performance. It's the recommended terminating link for most tRPC setups.",
      "file": "packages/client/src/links/httpBatchLink.ts",
      "highlight": [{ "start": 20, "end": 22 }],
      "title": "",
      "id": "1438"
    },
    {
      "type": "textOnly",
      "description": "Let's recap the main components of the @trpc/client package that we've explored in this tour:\n\n1. Client Creation: We learned how to create a tRPC client using `createTRPCProxyClient` or `createTRPCClient`.\n2. HTTP Batch Link: We discussed how the HTTP batch link optimizes requests by batching multiple procedure calls into a single HTTP request.\n3. Error Handling: We covered the `TRPCClientError` class and how to handle errors in your client-side code.\n4. Links: We briefly introduced the concept of links and their role in the request/response cycle.\n\nThese components form the foundation of the @trpc/client package and enable efficient communication with your tRPC server.",
      "title": "",
      "id": "1446"
    },
    {
      "type": "textOnly",
      "description": "The @trpc/client package offers several significant advantages for TypeScript developers:\n\n1. End-to-end Type Safety: It maintains type safety between your client and server, reducing the likelihood of runtime errors.\n2. Flexibility: The package provides various options for customization, allowing you to tailor the client to your specific needs.\n3. Optimization: Features like request batching and caching help optimize your application's performance.\n4. Seamless Integration: It works well with popular frontend frameworks and can be easily integrated into your existing TypeScript projects.\n5. Developer Experience: The strong typing and intuitive API design enhance the overall developer experience, making it easier to build and maintain your application.",
      "title": "",
      "id": "1447"
    },
    {
      "type": "textOnly",
      "description": "This concludes our high-level tour of the @trpc/client package. We've covered the main aspects of client creation, error handling, and briefly touched on links and other features. Remember that there are separate, more detailed tours available for concepts like data loaders and links if you want to dive deeper into those topics.\n\nThe @trpc/client package provides a powerful and flexible way to interact with your tRPC server, offering a great balance between simplicity and advanced features. As you continue to work with tRPC, you'll discover how this client package can significantly improve your development workflow and application performance.",
      "title": "",
      "id": "1448"
    }
  ]
}
